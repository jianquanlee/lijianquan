&emsp;&emsp;之前一直在做硬件HoG特征算子的实现，在调中间的一个Bug的时候发现了IP Core `LPM_DIVIDE`的一些被忽略的细节。

&emsp;&emsp;把这个IP Core当成一个简单的除法器去做，导致硬件计算结果和MATLAB仿真结果不一样。大家都知道对于硬件而言，26/10 = 2，这个肯定没问题，但是(-26)/(-10)呢，是等于多少呢。如果我们用MATLAB仿真的话，就是2.6，再向下取整，变成2。

&emsp;&emsp;但是要注意到，在LPM_DIVIDE这个IP Core里有一个这样的选项，并且默认的选项是Yes，

&emsp;&emsp;Always return a positive remainder? 就是说确保余数是正数？

&emsp;&emsp;对于两个正数相除，很好理解，26/10 = 2……6，所以除法的quotient端口输出的就是2，那么当被除数是负数，比如-26，(-26)/(-10) = 2……(-6)，如果允许余数是负数，那么上面的计算结果便是正确的，如果要求余数必须是正数，那么上面的结果就是不对的，正确的计算结果应该是(-26)/(-10) = 3……4，所以quotient端口输出的就是3。对于MATLAB来说，26/10和(-26)/(-10)的精确结果都是2.6，那么向上或者向下取整，得到的结果都是一致的，因此MATLAB仿真的结果就和硬件的结果对不上，因此需要根据被除数和除数的正负号来分别选择向上或者向下取整。
